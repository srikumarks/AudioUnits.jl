# Capturing Audio from AudioUnits
#
# This example demonstrates how to capture audio samples generated by
# AudioUnits. Since offline audio processing is still being developed,
# this example shows the working approach using realtime synthesis with
# MIDI and manual recording.

using AudioUnits

println("AudioUnits.jl - Audio Capture Example")
println("=" ^ 70)
println()

# ============================================================================
# Approach 1: Synthesize Audio with MIDI and Record in Realtime
# ============================================================================

println("Approach 1: MIDI Synthesis with Realtime Output")
println("-" ^ 70)
println()

println("This approach synthesizes audio from MIDI and captures it via the")
println("system's audio I/O. In a real application, you could:")
println()
println("  1. Create an AudioGraph with DLSMusicDevice (or other synth)")
println("  2. Connect it to your audio interface output")
println("  3. Record the output with external software (QuickTime, Audacity, etc.)")
println("  4. Or use a loopback device to capture audio programmatically")
println()
println("Example code structure:")
println()
code = """
    graph = AudioGraph()
    synth = load("DLSMusicDevice")
    output = addoutputnode!(graph)
    addnode!(graph, synth)
    connect!(graph, synth, output)
    initializegraph!(graph)
    initialize(synth)
    startgraph!(graph)

    # Your audio is now being synthesized and sent to your speakers
    # External recording tools can capture it

    stopgraph!(graph)
    uninitialize(synth)
    disposegraph!(graph)
"""
println(code)

println()
println("=" ^ 70)
println()

# ============================================================================
# Approach 2: Direct Audio Synthesis and Manual Capture
# ============================================================================

println("Approach 2: Using AudioUnit Parameters for Audio Generation")
println("-" ^ 70)
println()

println("Some AudioUnits generate audio based on MIDI. We can demonstrate")
println("the general pattern, though actually capturing the samples requires")
println("either:")
println()
println("A) Using SampleBuf with working audio processing functions")
println("B) Implementing a custom C callback that can safely handle buffers")
println("C) Recording via system audio I/O and processing externally")
println()

# Create a demo of the MIDI synthesis approach
println("Loading Apple: AUMIDISynth...")
au = load("Apple: AUMIDISynth")
initialize(au)

println("AudioUnit loaded: ", au.name)
println("Supports MIDI: ", supportsmidi(au))
println("Supports effects: ", supportseffects(au))
println()

# Query parameters to understand the synth
params = parameters(au)
println("Available parameters: ", length(params))
if !isempty(params)
    println("First few parameters:")
    for (i, param) in enumerate(params[1:min(3, length(params))])
        println("  - ", param.info.name, ": ",
                param.info.min_value, " to ", param.info.max_value)
    end
end
println()

uninitialize(au)
dispose(au)

println()
println("=" ^ 70)
println()

# ============================================================================
# Approach 3: Working Example - Synthesize and Process with SampledSignals
# ============================================================================

println("Approach 3: Recommended Workflow")
println("-" ^ 70)
println()

println("The most reliable current approach is:")
println()
println("1. Use realtime AudioGraph with startgraph!/stopgraph!")
println("   - Handles all audio buffering automatically")
println("   - Perfect for MIDI synthesis and effects")
println()
println("2. For offline audio processing:")
println("   - Implement your own custom buffer handling")
println("   - Or use external tools (DAW, ffmpeg, sox)")
println("   - Or wait for the processbuffer! functions to be redesigned")
println()

println("Example: Realtime MIDI Synthesis")
println("-" ^ 70)
println()

example_code = """
using AudioUnits

# Create graph
graph = AudioGraph()

# Load synth and effects
synth = load("DLSMusicDevice")
lowpass = load("AULowpass")
output = addoutputnode!(graph)

# Add to graph
synth_node = addnode!(graph, synth)
effect_node = addnode!(graph, lowpass)

# Connect: synth → lowpass → output
connect!(graph, synth_node, effect_node)
connect!(graph, effect_node, output)

# Initialize
initializegraph!(graph)
initialize(synth)
initialize(lowpass)

# Set effect parameters
if !isempty(parameters(lowpass))
    # Set cutoff frequency to 2000 Hz
    setparametervalue!(lowpass, parameters(lowpass)[1].id, 2000.0)
end

# Start audio
startgraph!(graph)

# Play notes
for note in [60, 64, 67, 72]
    noteon(synth, 0, note, 100)
    sleep(0.5)
    noteoff(synth, 0, note)
end

sleep(1.0)

# Stop and cleanup
stopgraph!(graph)
uninitialize(synth)
uninitialize(lowpass)
disposegraph!(graph)
"""
println(example_code)

println()
println("=" ^ 70)
println()

# ============================================================================
# Approach 4: Using SampledSignals (for future when offline processing works)
# ============================================================================

println("Approach 4: Future - Offline Processing")
println("-" ^ 70)
println()

println("Once the offline audio processing functions are fully implemented,")
println("you'll be able to do:")
println()

future_code = """
using AudioUnits, SampledSignals

# Create input audio
sr = 44100
input = SampleBuf(randn(Float32, 2, sr), sr)

# Load effect
lowpass = load("AULowpass")
initialize(lowpass)

# Set parameters
setparametervalue!(lowpass, 0, 2000.0)  # 2kHz cutoff

# Process (currently has architectural issues)
# output = processbuffer(lowpass, input)

# For now, use realtime approach instead
# ...

uninitialize(lowpass)
dispose(lowpass)
"""
println(future_code)

println()
println("=" ^ 70)
println()

println("For more examples, see:")
println("  - examples/realtime_graph.jl - Graph setup and realtime processing")
println("  - examples/simple_midi.jl - Simple MIDI synthesis")
println("  - examples/midi_example.jl - Advanced MIDI features")
println()
println("Status: Offline buffer processing (processbuffer, process!) is still")
println("being debugged. The realtime graph approach works great for synthesis")
println("and realtime effect chains!")
println()
